# 유니버설함수                                        유니버설함수

import numpy as np
arr = np.arange(10)
arr
# <출력> array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])

# 단항 유니버설 함수
np.sqrt(arr)
# <출력>
# array([0.        , 1.        , 1.41421356, 1.73205081, 2.        ,
#        2.23606798, 2.44948974, 2.64575131, 2.82842712, 3.        ])

np.exp(arr)
# <출력>
# array([1.00000000e+00, 2.71828183e+00, 7.38905610e+00, 2.00855369e+01,
#        5.45981500e+01, 1.48413159e+02, 4.03428793e+02, 1.09663316e+03,
#        2.98095799e+03, 8.10308393e+03])

np.exp(1)
# <출력> 2.718281828459045


# 이항 유니버설 함수
x = np.random.randn(8)
y = np.random.randn(8)

x
# <출력>
# array([-0.92636774, -1.03234076,  0.88873568, -2.62295015,
#       -0.06574232, -0.73575235,  1.52419632, -0.54659848])

y
# <출력>
# array([-0.86323147,  1.42525731,  0.95813418,  1.06844799,
#       -0.80584912,  0.87617239,  0.69338792, -0.33904493])

np.maximum(x, y)
# <출력>
# array([-0.86323147,  1.42525731,  0.95813418,  1.06844799,
#       -0.06574232,  0.87617239,  1.52419632, -0.33904493])


# 여러개의 배열을 반환하는 유니버설 함수
# modf 는 파이썬 내장 함수인 divmod 의 벡터화 버전. 분수를 받아서 몫과 나머지를 함께 반환
arr = np.random.randn(7) * 5

arr
# <출력>
# array([-4.61559807, -6.27729483, -2.73862412, -1.6747488 ,
#         1.84579876, -3.88012698, -6.65983194])

remainder, whole_part = np.modf(arr)
remainder
# <출력>
# array([-0.61559807, -0.27729483, -0.73862412, -0.6747488 ,
#         0.84579876, -0.88012698, -0.65983194])

whole_part
# <출력> array([-4., -6., -2., -1.,  1., -3., -6.])


# 선택적으로 out 인자 사용하여 계산 결과를 별도 저장
arr
# <출력>
# array([-3.06515156, -2.37130948,  1.29910599,  8.06321282,
#         5.04210424,  2.07303572,  1.19492223])

np.sqrt(arr)
# <출력>
# <input>:1: RuntimeWarning: invalid value encountered in sqrt
# array([       nan,        nan, 1.13978331, 2.83957969,
#        2.24546303,  1.43980405, 1.09312498])

np.sqrt(arr, arr)   #SQRT arr결과값을 arr에 저장
# <input>:1: RuntimeWarning: invalid value encountered in sqrt
# array([       nan,        nan, 1.13978331, 2.83957969,
#        2.24546303,  1.43980405, 1.09312498])




# 값이 놓여 있는 그리드에서 sqrt(x^2 + y^2)를 계산
# np.meshgrid 함수는 두개의 1 차원 배열을 받아서 가능한 모든 (x, y)짝을 만들 수 있는 2 차원 배열 두개를 반환
points = np.arange(-5, 5, 0.01)           # 1000 equally spaced points
xs, ys = np.meshgrid(points, points)
ys
xs

# 그리드 상의 두 포인트로 간단하게 계산 적용 가능
z = np.sqrt(xs ** 2 + ys ** 2)
z





# matplotlib             파이썬을 이용한 데이터 시각화                       matplotlib
import matplotlib.pyplot as plt
plt.imshow(z, cmap=plt.cm.gray); plt.colorbar()
plt.title("Image plot of $\sqrt{x^2 + y^2}$ for a grid of values")
plt.draw()
# re-draw. interactive mode 에서 data 나 format 을 바꾸어야 할 때 사용
plt.close('all')






# np.where
xarr = np.array ([1.1,1.2,1.3,1.4,1.5])
yarr = np.array([2.1,2.2,2.3,2.4,2.5])
cond = np.array ([True,False,True,True,False])

result = [(x if c else y) for x, y, c in zip(xarr,yarr,cond)]
result
# <출력> [1.1, 2.2, 1.3, 1.4, 2.5]


# np.where 이용
result = np.where(cond,xarr,yarr)
result
# <출력> [1.1, 2.2, 1.3, 1.4, 2.5]

# where 은 다른 배열에 기반한 새로운 배열을 생성
arr = np.random.randn(4, 4)

arr
# <출력>
# array([[ 0.20343263, -1.24549135,  0.04353215,  1.76619998],
#        [ 0.24949921,  1.54354193, -0.39978553,  0.02376734],
#        [ 1.38698041, -0.32689699,  0.18724001,  0.41467767],
#        [ 0.40090677, -0.19479791,  0.40132263, -0.34850082]])

arr > 0
# <출력>
# array([[ True, False,  True,  True],
#        [ True,  True, False,  True],
#        [ True, False,  True,  True],
#        [ True, False,  True, False]])

np.where(arr > 0, 2, -2)
# <출력> array([[ 2, -2,  2,  2],
#        [ 2,  2, -2,  2],
#        [ 2, -2,  2,  2],
#        [ 2, -2,  2, -2]])

# arr 의 모든 양수를 2 로 바꿈
arr
# <출력>
# array([[ 0.20343263, -1.24549135,  0.04353215,  1.76619998],
#        [ 0.24949921,  1.54354193, -0.39978553,  0.02376734],
#        [ 1.38698041, -0.32689699,  0.18724001,  0.41467767],
#        [ 0.40090677, -0.19479791,  0.40132263, -0.34850082]])

np.where(arr > 0, 2, arr)
# <출력>
# array([[ 2.        , -1.24549135,  2.        ,  2.        ],
#        [ 2.        ,  2.        , -0.39978553,  2.        ],
#        [ 2.        , -0.32689699,  2.        ,  2.        ],
#        [ 2.        , -0.19479791,  2.        , -0.34850082]])

arr
#<출력>
# array([[ 0.20343263, -1.24549135,  0.04353215,  1.76619998],
#       [ 0.24949921,  1.54354193, -0.39978553,  0.02376734],
#       [ 1.38698041, -0.32689699,  0.18724001,  0.41467767],
#       [ 0.40090677, -0.19479791,  0.40132263, -0.34850082]])

# np.where => 원본이 바뀌진않음  처음 불러왔던arr = np.random.randn(4, 4) 가 결과값으로 나옴


#######
arr = np.arange(32).reshape(8,-1)
arr
# <출력>
# array([[ 0,  1,  2,  3],
#        [ 4,  5,  6,  7],
#        [ 8,  9, 10, 11],
#        [12, 13, 14, 15],
#        [16, 17, 18, 19],
#        [20, 21, 22, 23],
#        [24, 25, 26, 27],
#        [28, 29, 30, 31]])

import numpy as np


#exis ; 1 은 컬럼으로 보는데 안에있는 요소 0은 row 2는 높이

arr = np.random.randn(5,4)

arr
arr.mean()
np.mean(arr)
# <출력> -0.15612707816159727
# arr.mean() = np.mean(arr)  값이 똑같다

arr.sum()
# <출력> -3.1225415632319455

arr.mean(axis=1)
# <출력> array([ 0.01952549,  0.12535683,  0.53172117, -0.96561754, -0.49162134])
arr.sum(axis=0)
# <출력> array([-0.67891732, -3.61662064, -1.36188536,  2.53488176])

# 누적합 누적곱
# cumsum cumprod

arr1=np.array([0,1,2,3,4,5,6,7])
arr1.cumsum()
# <출력> array([ 0,  1,  3,  6, 10, 15, 21, 28])


arr2=np.array([[0,1,2],[3,4,5],[6,7,8]])
arr2
# <출력>
# array([[0, 1, 2],
#        [3, 4, 5],
#        [6, 7, 8]])

arr2.cumsum(axis=0)
# <출력>
# array([[ 0,  1,  2],
#        [ 3,  5,  7],
#        [ 9, 12, 15]])

arr2.cumprod(axis=1)
# <출력>
# array([[  0,   0,   0],
#       [  3,  12,  60],
 #      [  6,  42, 336]])







# sum 메서드를 실행하면 불리언 배열에서 True 인 원소의 개수 셀 수 있다.
arr = np.random.randn(100)
(arr > 0).sum()
# <출력> 51



bools = np.array([False, False, True, False])

bools.any()
# <출력> True

bools.all()
# <출력> False

#.any() # 하나 이상의 값이 True 인지 검사
#.all()  # 모든 원소가 True 인지 검사


#  sort                                                                 sort
arr=np.random.randn(6)
arr
# <출력>
# array([ 1.81341706, -0.55495495,  1.08890978,  0.04406718,  1.98924833, -0.27492286])

arr.sort()
arr
# <출력>
# array([-0.55495495, -0.27492286,  0.04406718,  1.08890978,  1.81341706, 1.98924833])


# 내림차순
arr_dasc = arr[::-1]
arr_dasc
# <출력>
# array([ 1.98924833,  1.81341706,  1.08890978,  0.04406718, -0.27492286,-0.55495495])



# 다차원 [] 안의 내림차순
arr = np.random.randn(5,3)

arr
# <출력>
# array([[-2.24363158, -1.01167904, -0.9661356 ],
#        [-1.40012224,  0.24285708,  0.89566477],
#        [-0.39138188,  0.79215742,  0.17208338],
#        [ 1.49774096, -0.84961851,  0.10679284],
#        [-0.40281519, -0.99546957,  1.13569311]])


arr.sort (1)
arr
# <출력>
# array([[-2.24363158, -1.01167904, -0.9661356 ],
#        [-1.40012224,  0.24285708,  0.89566477],
#        [-0.39138188,  0.17208338,  0.79215742],
#        [-0.84961851,  0.10679284,  1.49774096],
#        [-0.99546957, -0.40281519,  1.13569311]])


arr_innerdesc = arr[:,::-1]
arr_innerdesc
# <출력>
# array([[-0.9661356 , -1.01167904, -2.24363158],
#        [ 0.89566477,  0.24285708, -1.40012224],
#        [ 0.79215742,  0.17208338, -0.39138188],
#        [ 1.49774096,  0.10679284, -0.84961851],
#        [ 1.13569311, -0.40281519, -0.99546957]])






# 배열 직접 변경 x -> 가지고 있는 복사본 반환
large_arr = np.random.randn(1000)
large_arr
large_arr.sort()
large_arr[int(0.05*len(large_arr))]



#  unique                                         unique = set 동일 ; 중복제거 에 의미를 둠
names = np.array(['Bob', 'Joe', 'Will', 'Bob', 'Will', 'Joe', 'Joe'])
np.unique(names)
# <출력> array(['Bob', 'Joe', 'Will'], dtype='<U4')


ints = np.array([3, 3, 3, 2, 2, 1, 1, 4, 4])
np.unique(ints)
# <출력> array([1, 2, 3, 4])


# np.inlod() ;두 개의 배열을 인자로 받아서 첫 번째 배열의 원소가 두 번째 배열의 원소를
        #     포함하는지 나타내는 불리언 배열을 반환
values = np.array([6, 0, 0, 3, 2, 5, 6])
np.in1d(values, [2, 3, 6])
# <출력> array([ True, False, False,  True,  True, False,  True])



# 불러오기 np.load() np.save()
arr=np.arange(10)
np.save('some_array',arr)
# <출력>

np.load('some_array.npy')
# <출력> array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])

np.savez('array_archive.npz',a=arr,b=arr)
# <출력>


arch = np.load('array_archive.npz')
arch['b']
# <출력>


np.savez_compressed('arrays_compressed.npz',a=arr,b=arr)
# <출력>
